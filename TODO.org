** DONE Tempo variants
** DONE TimeSignature variants
** DONE Simplify tests
** DONE Generic verb for return value with list randomization example
** DONE IO verb with no return type for toLily output via putStrLn to start
** DONE App infrastructure:
*** DONE Applicative OptParse for command-line args starting with YAML config
*** DONE Driver free monad with Env for config YAML, State for random generator
*** DONE Helpers for consuming config YAML.  
** DONE Test Infrastructure
*** DONE Verb to write toLily ouput to file
*** DONE Integrate driver with unit test
 1) get runDriver from Main in exec to Main in text to compile
 2) simple test that fails running lilypond
 3) fix failing test
 4) capture LilyPond stderr and show on failure
*** DONE Integration test infrastructure
 1) generate score with single voice
 2) run lilypond -- can just do "import System.Process .. exitCode <- system $ "lilypond " <> filename ... assert ExistSuccess == exitCode
 3) verify success via exit code (see above)
*** DONE Integration tests
 1) poly voices
 2) voice groups
 3) mixed single, poly, and group voices
** DONE Try consolidating types e.g. VoiceEventList
Failed mainly on simple wrappers for sum types Clef and Tempo,
also for sum types of products, e.g. TimeSignature.  Best solution
would be a mix of singletons Note, Rest, Chord, KeySignature, with
wrappers Cleff, Tempo, TimeSignature.  Seemed like a cleaner design
to stick with uniform wrappers for voice events, maybe with simplified
constructor names.
** DONE Answer random elment from list*
** DONE Answer n random elments from list no repeats
Unless n > length list.  Easy to make infinite list of
random items from a list.  Possible to take e.g. sub-lists
randomly, though there'll be repeats.  Good enough for 
starters.  For lack of repeats, could shuffle first, then
take up to n items which would be without repeats.  
** DONE Interval 
Given list list of Pitch, a (Pitch,Octave) pair, and a list of Int
answer the list of (Pitch,Octave) that corresponds to the transposition
by interval item in [Int].  Note this is a pure routine.
** DONE Config of interval motto
Consist of <digit> or 'r', parses as [Maybe Int] where
Nothing means rest, or absence of an interval.  
** DONE Parse parseLily . toLily for Score
** DONE Config params for sample app
Random mottos in multiple voices.
Mottos specified as collections of equal count lists:
 1) [Maybe Int] (Nothing will mean a Rest)
 2) [Duration]
 3) [Accent]
 3) [Dynamic]
Inputs also include:
  1) Scale
  2) (Pitch,Octave)
** DONE Initialize Random from seed
To determine the seed for getStdGen, in IO:
...
r <- mkStdGen
let s :: [Char] = show r
...
To initialize the seed for StdGen (note, pure!):
let r = read s::StdGen
...
See https://stackoverflow.com/questions/28035728/how-to-obtain-the-seed-used-by-haskells-rng
Need new command-line variable or config param to specify seed.
** DONE Reconsider abandoning MonadRandom in favor of State 
Can initialize global random number generator, then just use
it through MonadRandom.  Change in direction removes the need,
at least for now, of MonadState instead of MonadRandom.
Then stash StdGen in environment to convert it to string (or
just convert it immediately) for use during construction of 
Score later on.  And this didn't turn out to be so hard at all.
Appended StdGen to comment for re-use if desired.
** DONE Generate note list
To generate note list:
 1) pick random element from each of three config lists
 2) convert first list to [Maybe (Pitch,Octave)] using
    mtranspose where Nothing is preserved as Nothing.
 3) zip lists generating note or rest for each
To vary note lists:
 1) Scale
 2) starting (Pitch,Duration)
Don't worry about barring for now.
To generate a SingleVoice, have config data that
specifies voice and clef and use a default time signature.
** DONE Sample app to generate score with simple voice.
** DONE Fix midiInstrumentName
Needed to be Staff.midiInstrument not Voice.midiInstrument
** DONE Config file parsing
*** DONE Eliminate use of initial pitch/octave in transpostion
  When chaining, yields 1+n,n,n... sequences.
*** DONE Simplify octave parsing
  Parsing of octaves is too confusing, change form Lilypond
  parsing to simple +/- integer values with the octave at
  middle C being 0, 1 the octave above, -1 the octave below,
  and etc.
*** DONE Simplify list processing
  Space separations is a bad idea, change to commas for the
  individual lists, with ';' separator between lists, each
  token should accept before and after whitespace, too.
*** DONE Change sequencing of transpositions to use start
Accidental degree of freedom:  chaining motto transpositions
instead of restarting each motto from the same starting pitch.
Means motto shape is preserved but maybe over different starting
pitches based on end pitch from previous motto.
*** DONE Remove type keyword in config file
Means playing with parse order so parses don't interfere
with one another.  Spent the better part of Saturday 
nudging this into shape.
*** DONE Simplify grouping with before, after
First tried '[' and ']' but those parse to Aeson Array,
not string, so substituted '(' and ')'.  Eliminated need
for "only" with eof test.
*** DONE Parallel FromLily as FromConfig
Shouldn't have to parse to ConfigSelector type, then
pick apart with MonadFail handler.  With type class,
should be able just do parseConfig.  Segregate parsers
between lilypond ones and config ones in a new file,
Parsers.hs, have Lilypond instances just refer to 
parseLily<Foo>.  Create Config.hs to parallel Lilly.hs
and have Driver import both.
** DONE Control complexity
  Random groupings of a) pitches, b) rhythms, c) accents
  d) dynamics even for short sequences yields boring soup
  texture.  Create a new generation routine that creates
  n random associations and uses them as entities in the 
  asssembly of a larger texture.
  Or consider a progession where the existing strategy
  is the endpoint with the most complexity, e.g. random
  selection among a) interval/rest, b) duration, c) accent, 
  and d) dynamic.  How to progress from simple to more
  complex?  Consider taking uniform length list of inputs,
  interval/rest + duration + accent + dynamic.  (Can make
  uniform length following a couple rules: durations is 
  determinant, extend interval/rest with 0 transpositions
  for repeating same note, extend accent and dynamic with
  null ~.)  Then start with groupings of two and have random
  permutation of two-element list. Or, does it make sense
  to consider vertial slice of interval/rest + duration +
  accent + dynamic as integral and pick groupings 
  algorithmically?  It seems like it'd be hard to hear
  e.g. shuffled groups of 'n' elements as having anything
  to do with one another.  Say, as opposed to groupings
  of a shuffled list of three elements where each is a
  list of say three or four notes.  Which is where I was
  originally coming from.  In this pattern, a unit is 
  the motif as a list of four lists where the inner lists
  are of interval/rest, duration, accent, and dynamic.
  Or really, that would better be a struct with four
  elements or a four-tuple product.  The defining thing
  would be a constructor that would stretch out or clip
  the interval/rest, accent, and dynamic lists so they
  match the length of the duration list.  
*** DONE Minimal complexity:  same order homophonic
  Minimal complexity would be identical selection of each 
  in all voices, in a loop.  Repeat the exact same motifs
  just from different octave-separted initial notes?  Would
  be unison effect, certainly minimal complexity.  
*** DONE Medium complexity: same order polyphonic
  Rotate each voice by one motive, with as many motives
  as there are voices.  Effect is canon, so you hear 
  periodic repetitions in different octaves of motifs
  in the same order over and over.  Better than unison
  but not much.
*** DONE Random motifs.
  Among 'n' motifs, randomly pick one.  Repeat.  Trick 
  is for motifs to all be of the same rhythmic duration,
  otherwise you get staggered lengths.
  Tricky to lift monad behavior (randomizeList) into
  generation of voices.  Let's say I create a list of
  a list of notes by combining the input config params
  just in the order that they occur in the config file.
  That'd just be length four, which wouldn't be much to
  randomize, so multiply that by the number of repetitions.
  Now shuffle *that* list of list, which is going to be a 
  monadic operation.  Then concat the notes for the voice.
  Another possibility is for reps * count of elements in
  motifs, pick random one and concatenate the result. 
  
  Effect is like chorus where transitional passage comes
  back to restatement of idea without transition, or maybe
  ritornello.  It's grounded and static while continuously
  varying the series of motives between the voices.
*** DONE Fix rest rendering with dynamic change
  If there's a rest and there's a new dynamic, want to
  show dynamic.  Ignore accents.
*** DONE Change pitch/octave extension 
  Currently repeat to make note list match duration
  where needed.  Change to rests.
** DONE Crescendo/Decrescendo
To do swells over a tremolo or generally, need notation.  Can be a generic term
"swell" with values cresc, decresc, end, hairpin.  Or better yet I just need extra
values for dynamic that are cresc, decresc, end, and hairpin (espressivo) for
a swell on a single pitch.  Except I may want both dynamic and crescendo for the
same note, or dynamic and decrescendo for the same note.  I could have a list, 
but the actual instances of dynamic will be rare--and I'll have to get the order
of dynamic and swell correct.  So probably it makes better sense to keep them
separate.  Except, I forget: order varies between crescendo vs. decrescendo.
If there's a dynamic and a crescendo then that's the order.  But if there's a
dynamic and a decrescendo then you want the decrescendo first and the note second.
So really it would be better to have a pair as you can only ever have two, and
there's a handy NoDynamic and NoSwell for the empty cases.  Except that's not
really necessary, as I can customize ToLily instances by type and FromLily by
expected order.  But that only works (trivially) in the ToLily part.  The parsing
is harder.  The order of swell/dynamic vs. dynamic/swell means you can't use 
applicative style because the order in the containers e.g. Note has only one
shape.  I need a way to say parse swell + dynamic OR dynamic + swell but 
present them always in the order first dynamic then swell.  And while you can
trivially do a pair of (Either Swell Dynamic), you're still left with the
translation of that to Dynamic then Swell.  There is Text.Parsec.Perm that
I may be able to leverage.  But from my reading of the documentation, *all*
the fields of e.g. Note would be part of the mix, just so swell and dynamic
could be out-of-order.  The the parser would actually be much more general
than needed--would accept a much larger variety of input.  Seems like overkill,
like I'm just missing some part of the parser architecture.  

Simply god awful failure trying to force order of e.g. ">p" vs: "p<" which it
turns out, doesn't even matter to Lilypond!  Surprisingly difficult to create
a parser that handles two orders for the same type result.  In this case, I
wanted the result to be (Dynamic,Swell) but the order to occur in either order.
But as it turns out Lilypond takes "g''8.->\>\p" and g''8.->\p\> and treats 
them the same way!  

parseDynSwellPr :: Parser (Dynamic,Swell)
-- type checks but doesn't work for e.g. "\\f\\<", parses as (Forte,NoSwell)
parseDynSwellPr = try ((flip (,)) <$> parseSwell <*> parseDynamic) <|> try ((,) <$> parseDynamic <*> parseSwell)
-- type checks but doesn't work for e.g. "\\>\\f", parses as (NoDynamic,Decrescendo)
--parseDynSwellPr = try ((,) <$> parseDynamic <*> parseSwell) <|> try (flip (,) <$> parseSwell <*> parseDynamic)

So really, having a separate Dynamic and Swell is fine and it's just up to me
to get the order right.  Having both Dynamic and Swell means Lilypond will 
always render the dynamic first and the swell second.  The swell continues
until the next dynamic (maybe with another swell) or until a stop swell indicator.

** DONE Tremolo
Lilypond notation is :<N> where N is [8,16,32,64] for barring
of tremolo.  Though that sounds like it's a fail for Midi rendering.
So the way to encode it instead would be \repeat tremolo <reps> <note>[octave]<barring>
where reps * barring gives total duration, so \repeat tremolo 4 c16 is a quarter note
duration because 4 sixteenths gives a quarter note.  That's a little awkward.  First
of all, the tremolo indication will have to carry the barring: [8|16|32|64|128].  Then
there'll be a computation given a) the duration (1,1.,2,2.,4,4.,8,8. etc.] and b) the
barring, the duration will have to be evenly divisible by the barring.  It's tempting
to forgo the barring and just compute a lowest division maybe with some floor, like
e.g. sixteenths, that could be a global constant even.
But consider repeating a single note is only the minimal tremolo.  More usual is 
tremolo between two chords or, probably for marimba, between two pairs of notes.
And that's accommodated by the \repeat syntax.  But that encompasses multiple 
pitches, which means that it's probably better to have Tremolo as another VoiceEvent.
It wouldn't make any sense to use tremolo for a solo non-percussion voice, but that
doesn't have to be captured by the type.  The Tremolo VoiceEvent would include a 
list of notes of length one or two only.  Or better yet a [ [(Pitch,Octave)] ] of 
length one or two.  A tremolo on a single note would be just [ [(Pitch,Octave)] ],
over two single notes [ [(Pitch,Octave)], [(Pitch,Octave)] ], and etc.  Or another
possibility would be ([(Pitch,Octave)],[(Pitch,Octave)]) where a single note tremelo
would be represented as an empty list in the second element of the pair. Then it would
need Duration, and Dynamic but probably not Accent.  Finally, it could include a 
Maybe Duration for the barring, where Nothing would mean selecting a barring to fit
the Duration with a minimal value of e.g. 16.  And the code would compute the reps
value for the \repeat tremolo <reps> { '<' <note ... '>'<barring> ...}.
** DONE More Tremolo
For multiple-note tremolos, you can have a dynamic and/or swell associated
with each note:  \repeat tremolo 32 {<c' e'>\64\< <a' c''>64\f\>}. 
So really I Tremolo should be made up either a note or a pair of (maybe 
one-note) chords.
Tricky bits:  tried having two chords with different durations, didn't make
any sense in terms of the notation.  Left type alone with comment that two
durations should be identical because then it's just two chords.  Otherwise
it'd have to be two of a special type of Note without the duration then a 
single duration.  Don't forget to make a smart constructor for Tremolo that
checks the two Durations match.  
Lilypond renders accents, swells, and articulation even though articulations
aren't particularly meaningful.  Swells and dynamics are nice to vary over
course of the tremolo though unfortunately Lilypond doesn't render them via
Midi.
Lilypond also renders ties, which also aren't really meaningful.  Could 
rewrite as two tuples of (Note,Octave,Dynamic,Swell) plus Duration to make 
things explicit at the type level.
Also rewrote computation for barring of chords to avoid always jacking up
the barring to 128th notes.
Note for chords each note gets the total duration, which can be confusing.
The notes tremolo'd together make up a sustained note that lasts the duration
of one of the notated chords.
There's examples to show flipping the tremolo across staves if I ever need
it.
** DONE NonEmpty Lists
Follow Alexis King suggestion about non-empty lists as a type:
  https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/
Has the benefit of making non-empty lists visible to the type checker.
On parsing still run-time detection but part of parsing from config
data to internal data types vs. explicit check (which I wasn't doing
anyway).
Experience implementing it:  headed into trouble with monoid instance
for mappend of motto components, so there's some residual ordinary 
list processing in Compose.hs.  Points to usefulness of empty lists
when processing lists.
** DONE FadeOut rests
Add rests to voices that drop out.
** DONE NoteOrRest mods:  accents per section (including const per note)
Lilypond doesn't recognize and apply "sempre" annotations.
With piano, staccatissimo, staccato, etc. really make a difference as
the default touch is pretty legato.  But they have to be repeated with 
each note--they aren't sticky.  Replace Utils.hs:mkNoteOrRest where I 
just slap default Staccatissimo in and make it configurable.
** DONE NoteOrRest mods:  dynamics per section
Replaces global initialization in tagNote.
** DONE FadeIn/FadeOut Dynamics
After first segment, voices should drop down a dynamic level
so new voice predominates for a bit.
** DONE Text for Note
Add a text field for annotions for a note.  Default rendering
can be above, e.g. a8^"pizz" (see Notation, 1.8.1 "Writing Text").
** DONE Annotate sections with section and voice type text
Use text in voice textures to indicate start of a new rendering,
so e.g. during repeats for a neutral section you can see where 
voices repeat, same for a canon.  Just need a way to tag first
Note in [NoteOrRest].  
** DONE Deprecate initial config file and utility routines
Newest config file is much more sophisticated, will be updated 
to add transition sections.  Repeat of names "Compose.hs" and
"Utils.hs" is confusing.  
** DONE Progression:  pick N notes to randomly send up or down one octave
Programming this in gives a nice variation to texture for canon1 config.
But again you start hearing those outer notes getting repeated.  So it'd
be nice to have a way to progressively add more/remove more notes in the
registers above and below.
What does this look like?  In this case there'd be a section comprising
multiple voices and multiple segments.  So that'd include the neutral 
section with repeats and it'd include fade in and fade out sections.
And as part of the section desciption, there'd be the name of one or 
more routines to modify each voice for each segment.  Input to the 
routine would be the count of voices, the number of the voice, the count
of segments, the number of the segment, and the config tuple for the
voice.  Output would be a modified config tuple.
** DONE autochange
Swap out my code to split a single note or rest stream between clefs in favor
of the Lilypond autochange keyword.
Create a new voice type:  PianoVoice and revert PolyVoice.
For PianoVoice, use \new Staff = "up" and \new Staff = "down" for treble and bass.
Then when emitting markup for tempo, key, and time, also include "\autochange {" with
a terminating "}" before the concluding \bar "|."
Note: this generates a handful of warnings:
Interpreting music...
warning: no music found in score
Drawing systems...
canon.ly:41:3352: warning: no viable initial configuration found: may not find good beam slope
... and etc. for each voice.
These seem to be benign.
Or, create a special voice, SplitStaffVoice, as this seems like a very special case.
Render it as a single PianoStaff with the autochange keyword to distribute the VoiceEvents.

Got this to work at very end of the day after putzing about with parser, which is usually the
hard part.  Then overnight I realized there's an even simpler Lilypond variant where I don't
specify up and down staffs and Lilypond does it all.  Got that to work with test suite, then
discovered that midi output groups the "up" voices together and the "down" voices together,
which makes doing things like paning between the voices harder. 
So comment-out simple implementation and mark to be deprecated.
** DONE Change NoteOrRest to VeEvent
The way to enable Chord, Tuplet, and Tremolo events, eventually Rhythm too.
*** TODO Update Config to allow Chord, Tremolo, and Tuplet.
For Chord, update list of (Maybe Pitch,Octave) pairs to be [Pitch,Octave] with the empty list to match (Nothing,_) as a rest.
For ease of notation, parse () to [], (a,0) to [(A,COct)], and ((a,0),(b,1)) to [(A,0),(B,1)] to have e.g. mixed sublists, 
output type is [VeEvent] that comprise VeRest, VeNote, VeChord:
  pitOcts = ((a,0),((a,0),(b,0)),(c,1))  maps to  [VeNote,VeChord,VeNote]
  pitOctss = (((a,0),((a,0),(b,0)),(c,1)),(),((a,0),((a,0),(b,0)),(c,1))) maps to [[VeNote,Vechord,VeNote,VeRest..]
Whops, but that doesn't work because I need duration!  But then, I need Duration for Rest also.
Ugh, so it's not sufficient to go direction to VeEvent from list of (Pitch,Octave).  I need an intermediate representation
of Rest, so that means a uniform encapsulation in an outer list or a Maybe type.  The list encapsulation seems bogus, so
that means [Maybe (Pitch,Octave)] with Nothing to indicate Rest.  But to handle a chord, I actually need [Maybe [(Pitch,Octave)]]
anyway, so I could go with [ [(Pitch,Octave)] ] and an empty inner [] to indicate Rest.  But that seems mysterious, so start
with [Maybe [(Pitch,Octave)]] with Just [(Pitch,Octave)] for a Note and Just [(Pitch,Octave),(Pitch,Octave)...] for a Chord,
and Nothing for Rest.  Which has to get fixed up later on with Duration.

Ugh, but what about Tremolo then?  These are reprsented as a Coproduct of NoteTremolo, which just as a single Note vs.
ChordTremolo, which as two Chords, left and right.  So NoteTremolo is fundamentally Ok, as I have a way to designate a
Note.  But for ChordTremolo I need a way to group two Chords (eventually), which means two Chord inputs, whereas I just
figured out a way to do a single Chord.  Given the special-purpose nature of Tremolo and the awkwardness of fitting it 
into a generic input type, I think I'm going to punt on this for now and treat it as a special case in the future.

Then for Tuplet, I've got numerator, denominator, and dur to indicate for ... ugh, some arbitrary list of Notes with 
complicated constraints on the note durations and the sum of the note durations.  What I'm looking at here is the 
configuration data for the pitch,octave pair and how to denote rest, single note, and chord in one format.  None of 
this involves duration, and so many things are a bit more orthogonal in that a tuplet is going to be some enhancement
to the list of list of durations as currently supported:

      durss:    ((8,16,16),(8.,16),(8,8,8))

Now let's say I want a way to show a 3/2 tuplet of three eighths in the space of two.  Ugh.  I could have an intpreted
sublist, which you have to know the values are (numerator, denominator, duration).  

      durss:    ((8,16,16),(8.,16),(8,8,8),((3,2,8)))

But whereas I originally have a [ [Duration] ], what do I have instead for that inside list?  Those first two values
are just Int, not Duration.  I could go with Either Duration (Int,Int,Duration) or just give the tuple a name to 
disambiguate beteween numerator and denominator.  But really, then I also need a count of notes:

      durss:    ((8,16,16),(8.,16),(8,8,8),((3,2,8,3)))

And that only works for uniform durations so e.g. above, sixteenth notes.  So maybe it'd be better to have a list of
Duration:  Either Duration (Int,Int,Duration,[Duration]), ugh, DurationOrTuple.

      durss:    ((8,16,16),(8,16),(8,8,8),(8,(3,2,8,(16,8,16,16,16)),4))

*** TODO Consider lenses 
As I move away from a simplifeid type like NoteOrRest to VeEvent will I find lenses to be more useful?  There's only a bit
more structure from VoiceEvent to Note|Rest|... 
** DONE Tuple notation for rhythms in config files
Rhythmic configurations look like this:
  durss:   ((1,2,4.),(8,16),(8,8,8,4))
Add a way to group inside a duration list for tuples, e.g.:
  durss:   ((1,2,4.),(8,16),(-8,8,8-,4)) 
or:
  durss:   ((1,2,4.),(8,16),((8,8,8),4)) 
The tuple would be implicitly n:n-1, so for examples above, 
triplets as 3:2.
Going to make interpretation of [Duration] much more complicated.
For one thing, Tuplet type should have _tupNoteOrRest :: NonEmpty NoteOrRest
instead of _tupNote :: NonEmpty Note.  
But there needs to be a way to capture a tuplet as a pure Duration as
well, before it gets lined up with a list of notes/rests.  Given that
the time signature is unknown, it'll probably just have to be an inner
[Duration], turning each [Duration] into [ [Duration] ] where a single item
list e.g. [EDur] corresponds to a single item in the original [Duration]
and multiple-item list [EDur,EDur,EDur] counts as a tuplet.  Note that 
a [Duration] is over-broad, as [Edur,EDur] makes no sense as a tuplet.
But really, that's the only one, as once you're past a two-item list,
the n:(n-1) formula gives you 3:2, 4:3, 5:4, and etc. as expected.  So
it's a type of NonEmpty with minimum count of 3.  Note even this is 
simplified, as a real tuplet might have more than n-1 for the actual
duration, as in 5:3 or even 5:1.  However, that's going to make 
notating the tuple quite a bit harder, unless there's some internal
encoding, like a list of interpreted ints, e.g.:
  (<#denom>,(Dur,Dur,Dur)) 
as in 
  (2,(EDur,EDur,EDur)) 
for an eighth note triplet, or 
  (3,(QDur,QDur,QDur,QDur,QDur))
for a quarter-note 5:3 tuplet.
The parsing validation would be that the list of Durations was always
at least length n+1 where n is the count in the first item.
So my earlier example would look like:
  durss:   ((1,2,4.),(8,16),((2,(8,8,8)),4)) 
Although for simpler parsing, it'd be better to do:
  durss:   ((1,2,4.),(8,16),(((8,8,8),2),4))
Finally, I'd need something more than just a [ [Duration] ] to capture
a tuple, as there's now the denominator count as well.  So what was a
simple [Duration] would turn into something like [DurationOrTuple] with
Left Duration and Right DurationTuple where DurationTuple would be a
record with list of Duration for numerator and count of duration for 
denominator.
Another thing to check is the use of Tuple in the context of NoteOrRest,
because now a Note could be a Note or a a Tuplet, though even that's
misleading because a tuplet might have a mix of notes and rests.
Either way, replacing the NoteOrRest with NoteOrRestOrTuplet is 
going to be a challenge because now alignNoteOrRestsDurations takes
a [NoteOrRestOrTuplet].  I suppose the Note and Tuplet can be dealt
with comparably, though there has to be a way to recognize transition
of a tuplet across a bar line into a new bar, which could be tricky.
** DONE Fill-in/Fade-out  
  To fill-in, introduce voices one-by-one playing 
  single motif, then increase density across all voices.
  Reverse to fade-out.
** TODO cfg2Score assumes all sections have equal number of Voices
This line ...
  let nOrRss = concat <$> transpose nOrRsss
... won't work properly if the inner list of list of NOrRs ([ [NOrRs] ]) aren't all of the
same length, i.e. have the same number of voices.

Here's the success case:

Prelude Data.List> concat <$> transpose [[[1,2,3],[10,20,30],[40,50,60]],[[101,102,103],[110,120,130],[140,150,160]],[[201,202,203],[210,220,130],[240,250,260]]]
concat <$> transpose [[[1,2,3],[10,20,30],[40,50,60]],[[101,102,103],[110,120,130],[140,150,160]],[[201,202,203],[210,220,130],[240,250,260]]]
[[1,2,3,101,102,103,201,202,203],[10,20,30,110,120,130,210,220,130],[40,50,60,140,150,160,240,250,260]]

Here's the failure case:

Prelude Data.List> concat <$> transpose [[[1,2,3],[10,20,30],[40,50,60]],[[101,102,103],[110,120,130]],[[201,202,203],[210,220,130]]]
concat <$> transpose [[[1,2,3],[10,20,30],[40,50,60]],[[101,102,103],[110,120,130]],[[201,202,203],[210,220,130]]]
[[1,2,3,101,102,103,201,202,203],[10,20,30,110,120,130,210,220,130],[40,50,60]]

Need a configuration to capture juxtaposition of multiple choirs each with different counts of voices.

** TODO Homophonic configuration
I've changed my mind about doing this as a config mod due to the need to 
process all voices at once.  Instead, there should be a new section type,
homphonic, with its own list of voices.  Which should be of what type?
Note that this will probably obsolete VoiceConfigRepeat, as it just makes
the whole thing vastly more configurable as a frozen version of something 
like VoiceConfigCanon.  In fact, VoiceConfigCanon could be simplified as 
well, as there's a fairly arbitrary design to the current implementation, 
which rotates "canon" so it's always a full voice, and which only rotates 
the pitch/octave list picked randomly from the list-of-list in the config, 
and doesn't rotate e.g. the list-of-list of durations or accents.  In 
fact, when you consider the larger scope, rotating a random element in a
nnlist of (Maybe Pitch, Octave) pairs is a pretty minor tweak in the context
of the randomization of those elements in the first place.  I wonder how
audible it'd be to compare with fade-in of non-canonical voices, if at all.
The biggest effect is to avoid each voice starting with the exact same 
pitch, given that the two sub-elements of the list-of-list of pairs is 
identical.  
Consider generally the degrees of freedom available, both latent and
special-purpose.  
Latently, there's the randomization of the series of sublists plucked
from the list-of-lists of (Maybe Pitch,Octave) pairs, Durations, and Accents.
These are common to the three current config types, transpose, repeat, 
canon.  The repeat voice randomizes the sublists once, then freezes that
randomization, which it does for the three parameter types above.  So 
that's one end of the degree of freedom.  The transpose and canon types
randomize all three parameters, with canon rotating just the (Maybe Pitch,Octave)
parameter as well.  Transpose ends the sequence when the pitch traverses the
target range.  Repeat and canon end at a specific duration.  
Just like I imagine parameterizing a homophonic section with a list of 
list of voices by voice index where some subset of parameters would be
common like especially durations, I can see having e.g. a way to selectively
randomize a canon.  Or maybe this is jumping ahead, and the baseline should
be the the repeat mechanism to which I add degrees of freedom, e.g. repeated
randomization of sublist selection and rotation to mix things up.  Then as
a separate dimension there's the idea of shared parameters *between* voices
which brings in the homophony.
So the maximum configurability would be a way to identify behaviors orthogonally
for each of the three list-of-list data types per voice.  Or maybe have a default
configuration that says to permute them all all the time.  But to get more 
refined than that, I'd have a list of flags per voice, one list for each type.
The list would be organized by voice index.  The value in the list could be
a Bool flag to say to permute or to freeze.  Then if I wanted to have multiple
segments, I'd have a list of a list of Bool, with outer list by voice and inner
list by section.  And maybe I'd also have a list of durations so each segment
wouldn't have to be the same duration.  And if the default behavior is to permute,
then I could say an empty list for a voice means to permute each segment for that
voice, and an empty list of lists means always permute all voices for all segments.
In this sense, the default behavior is to permute, which the configuration 
overrides.  Alternatively, I could make *not* to permute the default behavior and
selectively override to allow permutation.  That makes for a quicker trial
implementation, leaving the configuration bits until later.
However, just fixing the individual sequences for a given segment doesn't actually
remove that much from the texture, at least not when sticking with the same config
as for the canon.  That's because though the sequence of sublists doesn't vary, 
the different lengths or different counts of items in the sublists means the match
up with notes and rests constantly varies: 11 accents to 10 durss to 28 pitch/octave
pairs. 
** TODO NOrR mods 
*** Trim or pad all voices in a section to a particular length
Variation might be to dynamically back up from the end to the last point 
before first voice becomes all rests.
** TODO Retrograde, Inversion, and Retrograde Inversion
Same row over and over winds up hammering in repetition.
Could add another item to the configuration which is a list of
orderings (n,r,i,ri) for normal, retrorade, inverted, and 
retrograde inverted, then add those to the random soup.
Note the octave banding is going to naturally call out the 
highes and lows.
Experimented with different ranges to avoid hammering on same
highs and lows and effect tended toward mush, losing the 
jazzy rhythms of the combined voices in the same range.
Repetition problem ptends to go away with shorter fadein/fadeout 
sections, less of one voice playing over and over same thing.
** TODO Progressively intensify/de-intensify
With piano texture, accents tend to overwhelm dynamic.
Have a way to tune up or tune down a parameter like accent
or dynamic level of the course of several segments.  So to
tune up accents you could start by suppressing them all in
the config, then incrementally scale them up over the course
of the count of segments.  Similarly for the dynamic marker
for a segment, going toward the the dynamic indicated in the
config or away from it.  Or maybe a dynamic would just be a
once-and-done to annotate the first note at the beginning of
a section.
** TODO Re-Architect Driver
First: ToLily doesn't need to be monadic at all, and can just be a 
library routine.
Second:, FromLily and FromConfig both use monadic parsers, but have 
nothing to do with IO and there's no reason for them to be encapsulated, 
either.  The only thing that happens in Driver is pasing in the path to 
the config file as an DriverEnv.
Third: the random behavior all takes place with respect to MonadRandom,
and can probably be run under the IO monad without the need of the 
runDriver wrapper and free monad entirely.
Fourth: generation of actual LilyPond file is just writeFile in IO.
Really, there's no need for the free Monad without a grammar that's
recursive in its own right.  But none of my syntax recurs, so all I
get is composability throught the bind and sequence operators, which
I don't actual make use of anyway.
** TODO Rethink fold vs. unfold.
The normative reference for free monad is a catamorphism e.g. fold.
Reduction through evaluation of an expression captured via a syntax
tree to a value.  The closest I come to this is the mapping of a 
structured type like Score to a simple type like a String, with all
the LilyPond syntax embodied in it.
But when it comes to composition what I'm really talking about is 
unfolding, an anamorphism, or a comonad, where there's some pre-defined
stopping point to the unraveling or adumbration of the unfolding e.g.
at some iteration count.  That's the generative process that yields
either the Score or some abstraction that is then mapped to the Score
before being reduced to a LilyPond string.
The mental block I've experienced even back during Cisco days results
from this basic inversion of the abstraction, the fact that what I seek
is the unfold prior to the fold, the anamorphism prior to the catamorphism. 
** TODO Tremolo Sample Texture
Sustained one, two, and four-note tremolos seems reasonable, so long
as the four-note tremolos are organized 2+2 and there's not too much
distance between the two pitches.  From looking at a couple videos,
it seems like a sixth is reasonable, even in both hands with rolls
or tremolos for the sustained effect.  So assuming four marimbas,
there's a range that starts with single notes per marmimba for a
total of four pitches through double notes in both hands for a 
total of 16 pitches.  What appeals to me is clusters of sixths
paired with octaves.  So maybe a starting point would be interleaved
octaves and sixths each with independent swells, though I'm going to
have to hand-annotate those in Logic myself.
Consider fifth cycles up via major sixths:
1) c  eb + octave ab
2) g  bb + octave eb
3) d  f  + octave bb
4) a  c  + octave f
...
Other way around moves down by minor thirds:
1) c  eb + octave ab
2) a   c + octave f
3) fs  a + octave d
4) ds fs + octave b
...
Either way cross over of minor second/major seventh
will add some friction.
Starting initial descending major sixth as input, e.g. c + eb:
1) produce octaves at lower fifth: ab + ab
2) using ab as next point, produce new descending sixths
   starting from half step up:  a + c
3) repeat with those pitches as next stage.
Abstract: octaves go up half step vs. down half step.
Octave selection has to vary so tonal center doesn't
uniformly migrate.
Trick would be to have generator that adds complexity on successive
iterations.  Pattern for generator is comonad, if you want to generalize
beyond lists (e.g. unfoldr).  In my mind, first generation would be
four marimbas, one sustained pitch per marimaba, next generation would
be four marimbas, two systained pitches per marimaba, final generation
four marimbas, four systained pitches per marimba.  Each generation 
would be complete cycle of fifths but more dense texture.  Final
generation would be easier to map as upper and lower sixths, with
outer notes as octave, inner notes as sixths.  Middle generation 
would be either octaves and sixths per player or lower and uppper
sixths per player.  
Original plan was overlap, e.g. first sixths, then octaves, then
sixths, then octaves staggered.  Joins can be overlapping fifth
progressions on top of overlapping sixths and octaves.

But before that I need something conceptually simpler to build upon.
Start will be scaffolding of pitch progressions expressed as intervals,
defining characterstics:

a) starting pitch
b) interval: major sixth lower
c) interval: major fifth lower
d) interval: two octaves higher 

Note: sustaining c (starting pitch) as pivot 
to new  lower-half of major sixth gives continuity
to minor third progression.

** TODO Finish non-pitched percussion voice rendering.
** TODO Install Docker, install lilypond, run test under Docker
Should be possible to execute with GitHub integration.
** TODO Contrary texture
Instead of voices with separate ranges, all voices following
trajectories across same range.  More a chase even, with swarm 
that follows general countour but with each varying in details
of rhythm and exact pitch trajectories.  Model on the murmuration
(not a bad title).  Could even model graphic algorithm with leader
and followers.
Revisit weighted random generation with history.  Start simple e.g.
with just rhythm, e.g. duration.  Pick collection say of three:
1/16, 1/8, 1/4.  Assign weights: 1, 1, 2.  That is, 25%, 25%, 50%
probability on each choice.  To implement, pick random number from
range that is sum 4, e.g. 0..3.  Then create a list of duration
four elements long with 1/16 in first, 1/8 in second, and 1/4 in
last two, e.g.:
> concat $ zipWith replicate [1,1,2] [16,8,4]
[16,8,4,4]
Or $ concat . (zipWith replicate) is
Then use randomElement to pick one, or just wrap in new routine 
randomWeightedElement that takes weights as well as list.  Note
that it would be better to input a list of pairs explicitly to 
avoid truncation that can happen with zip.  And it makes for a 
more succinct implementation:  concatMap (uncurry replicate).
For this, config can just be 
 1) list of weights as ints
 2) list of durations
 3) count of elements to generate
 4) instrument
 5) note.
Or better yet, make a parser that knows (Int,a) pairs and a parser
for a list of them.
Also, consider filling out the percussion instruments so I can use
claves.
** TODO Motif Transitions
  - build longer-term transitions on top, e.g. migrate all 
    voices to a destination range: high, middle, low or
    transpose chromatically so different voices or pairs
    of voices are in different keys, or migrate starting
    mottos by cloning and repeating subsections or going
    the opposite direction so texture becomes either more
    sparse or more dense (e.g. by adding / removing rests),
    or units of repetition grow/shrink
  - pair-wise progressions so there's audible variety in
    the texture, e.g. outer voices chiming with inner 
    voices quietly busy
  - increasing sparsity of notes vs. rests to reduce
    texture to pointillistic dots
** TODO Barring


