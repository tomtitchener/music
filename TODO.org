** DONE Tempo variants
** DONE TimeSignature variants
** DONE Simplify tests
** DONE Generic verb for return value with list randomization example
** DONE IO verb with no return type for toLily output via putStrLn to start
** DONE App infrastructure:
*** DONE Applicative OptParse for command-line args starting with YAML config
*** DONE Driver free monad with Env for config YAML, State for random generator
*** DONE Helpers for consuming config YAML.  
** DONE Test Infrastructure
*** DONE Verb to write toLily ouput to file
*** DONE Integrate driver with unit test
 1) get runDriver from Main in exec to Main in text to compile
 2) simple test that fails running lilypond
 3) fix failing test
 4) capture LilyPond stderr and show on failure
*** DONE Integration test infrastructure
 1) generate score with single voice
 2) run lilypond -- can just do "import System.Process .. exitCode <- system $ "lilypond " <> filename ... assert ExistSuccess == exitCode
 3) verify success via exit code (see above)
*** DONE Integration tests
 1) poly voices
 2) voice groups
 3) mixed single, poly, and group voices
** DONE Try consolidating types e.g. VoiceEventList
Failed mainly on simple wrappers for sum types Clef and Tempo,
also for sum types of products, e.g. TimeSignature.  Best solution
would be a mix of singletons Note, Rest, Chord, KeySignature, with
wrappers Cleff, Tempo, TimeSignature.  Seemed like a cleaner design
to stick with uniform wrappers for voice events, maybe with simplified
constructor names.
** DONE Answer random elment from list*
** DONE Answer n random elments from list no repeats
Unless n > length list.  Easy to make infinite list of
random items from a list.  Possible to take e.g. sub-lists
randomly, though there'll be repeats.  Good enough for 
starters.  For lack of repeats, could shuffle first, then
take up to n items which would be without repeats.  
** DONE Interval 
Given list list of Pitch, a (Pitch,Octave) pair, and a list of Int
answer the list of (Pitch,Octave) that corresponds to the transposition
by interval item in [Int].  Note this is a pure routine.
** DONE Config of interval motto
Consist of <digit> or 'r', parses as [Maybe Int] where
Nothing means rest, or absence of an interval.  
** DONE Parse parseLily . toLily for Score
** DONE Config params for sample app
Random mottos in multiple voices.
Mottos specified as collections of equal count lists:
 1) [Maybe Int] (Nothing will mean a Rest)
 2) [Duration]
 3) [Accent]
 3) [Dynamic]
Inputs also include:
  1) Scale
  2) (Pitch,Octave)
** DONE Initialize Random from seed
To determine the seed for getStdGen, in IO:
...
r <- mkStdGen
let s :: [Char] = show r
...
To initialize the seed for StdGen (note, pure!):
let r = read s::StdGen
...
See https://stackoverflow.com/questions/28035728/how-to-obtain-the-seed-used-by-haskells-rng
Need new command-line variable or config param to specify seed.
** DONE Reconsider abandoning MonadRandom in favor of State 
Can initialize global random number generator, then just use
it through MonadRandom.  Change in direction removes the need,
at least for now, of MonadState instead of MonadRandom.
Then stash StdGen in environment to convert it to string (or
just convert it immediately) for use during construction of 
Score later on.  And this didn't turn out to be so hard at all.
Appended StdGen to comment for re-use if desired.
** TODO
To generate note list:
 1) pick random element from each of three config lists
 2) convert first list to [Maybe (Pitch,Octave)] using
    mtranspose where Nothing is preserved as Nothing.
 3) zip lists generating note or rest for each
To vary note lists:
 1) Scale
 2) starting (Pitch,Duration)
Don't worry about barring for now.
To generate a SingleVoice, have config data that
specifies voice and clef and use a default time signature.
** TODO Sample app to generate score with simple voice.
** TODO Barring
** TODO Non-pitched Percussion Voices

