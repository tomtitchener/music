** DONE Tempo variants
** DONE TimeSignature variants
** DONE Simplify tests
** DONE Generic verb for return value with list randomization example
** DONE IO verb with no return type for toLily output via putStrLn to start
** DONE App infrastructure:
*** DONE Applicative OptParse for command-line args starting with YAML config
*** DONE Driver free monad with Env for config YAML, State for random generator
*** DONE Helpers for consuming config YAML.  
** DONE Test Infrastructure
*** DONE Verb to write toLily ouput to file
*** DONE Integrate driver with unit test
 1) get runDriver from Main in exec to Main in text to compile
 2) simple test that fails running lilypond
 3) fix failing test
 4) capture LilyPond stderr and show on failure
*** DONE Integration test infrastructure
 1) generate score with single voice
 2) run lilypond -- can just do "import System.Process .. exitCode <- system $ "lilypond " <> filename ... assert ExistSuccess == exitCode
 3) verify success via exit code (see above)
*** DONE Integration tests
 1) poly voices
 2) voice groups
 3) mixed single, poly, and group voices
** DONE Try consolidating types e.g. VoiceEventList
Failed mainly on simple wrappers for sum types Clef and Tempo,
also for sum types of products, e.g. TimeSignature.  Best solution
would be a mix of singletons Note, Rest, Chord, KeySignature, with
wrappers Cleff, Tempo, TimeSignature.  Seemed like a cleaner design
to stick with uniform wrappers for voice events, maybe with simplified
constructor names.
** DONE Answer random elment from list*
** DONE Answer n random elments from list no repeats
Unless n > length list.  Easy to make infinite list of
random items from a list.  Possible to take e.g. sub-lists
randomly, though there'll be repeats.  Good enough for 
starters.  For lack of repeats, could shuffle first, then
take up to n items which would be without repeats.  
** DONE Interval 
Given list list of Pitch, a (Pitch,Octave) pair, and a list of Int
answer the list of (Pitch,Octave) that corresponds to the transposition
by interval item in [Int].  Note this is a pure routine.
** DONE Config of interval motto
Consist of <digit> or 'r', parses as [Maybe Int] where
Nothing means rest, or absence of an interval.  
** DONE Parse parseLily . toLily for Score
** DONE Config params for sample app
Random mottos in multiple voices.
Mottos specified as collections of equal count lists:
 1) [Maybe Int] (Nothing will mean a Rest)
 2) [Duration]
 3) [Accent]
 3) [Dynamic]
Inputs also include:
  1) Scale
  2) (Pitch,Octave)
** DONE Initialize Random from seed
To determine the seed for getStdGen, in IO:
...
r <- mkStdGen
let s :: [Char] = show r
...
To initialize the seed for StdGen (note, pure!):
let r = read s::StdGen
...
See https://stackoverflow.com/questions/28035728/how-to-obtain-the-seed-used-by-haskells-rng
Need new command-line variable or config param to specify seed.
** DONE Reconsider abandoning MonadRandom in favor of State 
Can initialize global random number generator, then just use
it through MonadRandom.  Change in direction removes the need,
at least for now, of MonadState instead of MonadRandom.
Then stash StdGen in environment to convert it to string (or
just convert it immediately) for use during construction of 
Score later on.  And this didn't turn out to be so hard at all.
Appended StdGen to comment for re-use if desired.
** DONE Generate note list
To generate note list:
 1) pick random element from each of three config lists
 2) convert first list to [Maybe (Pitch,Octave)] using
    mtranspose where Nothing is preserved as Nothing.
 3) zip lists generating note or rest for each
To vary note lists:
 1) Scale
 2) starting (Pitch,Duration)
Don't worry about barring for now.
To generate a SingleVoice, have config data that
specifies voice and clef and use a default time signature.
** DONE Sample app to generate score with simple voice.
** DONE Fix midiInstrumentName
Needed to be Staff.midiInstrument not Voice.midiInstrument
** DONE Config file parsing
*** DONE Eliminate use of initial pitch/octave in transpostion
  When chaining, yields 1+n,n,n... sequences.
*** DONE Simplify octave parsing
  Parsing of octaves is too confusing, change form Lilypond
  parsing to simple +/- integer values with the octave at
  middle C being 0, 1 the octave above, -1 the octave below,
  and etc.
*** DONE Simplify list processing
  Space separations is a bad idea, change to commas for the
  individual lists, with ';' separator between lists, each
  token should accept before and after whitespace, too.
*** DONE Change sequencing of transpositions to use start
Accidental degree of freedom:  chaining motto transpositions
instead of restarting each motto from the same starting pitch.
Means motto shape is preserved but maybe over different starting
pitches based on end pitch from previous motto.
*** DONE Remove type keyword in config file
Means playing with parse order so parses don't interfere
with one another.  Spent the better part of Saturday 
nudging this into shape.
*** DONE Simplify grouping with before, after
First tried '[' and ']' but those parse to Aeson Array,
not string, so substituted '(' and ')'.  Eliminated need
for "only" with eof test.
*** DONE Parallel FromLily as FromConfig
Shouldn't have to parse to ConfigSelector type, then
pick apart with MonadFail handler.  With type class,
should be able just do parseConfig.  Segregate parsers
between lilypond ones and config ones in a new file,
Parsers.hs, have Lilypond instances just refer to 
parseLily<Foo>.  Create Config.hs to parallel Lilly.hs
and have Driver import both.
** TODO Control complexity
  Random groupings of a) pitches, b) rhythms, c) accents
  d) dynamics even for short sequences yields boring soup
  texture.  Create a new generation routine that creates
  n random associations and uses them as entities in the 
  asssembly of a larger texture.
  Or consider a progession where the existing strategy
  is the endpoint with the most complexity, e.g. random
  selection among a) interval/rest, b) duration, c) accent, 
  and d) dynamic.  
  Minimal complexity would be identical selection of each 
  in all voices, in a loop.

  First step could be to advance interval/rest by one, 
  wrapping to maintain order.  The pairing of duration,
  accent, and dynmamic would continue.  In fact, it's
  hard to imagine playing with the accent/dyanmic pair
  independently except against a drone of a stable interval,
  duration pairing.  And even then you'd want to do 
  something like drop the overall dynamic and just have
  the voices chorus on the accent patterns.

  And maybe do it voice-by-voice, pulling the wrapping
  ahead successively.  

  Or experiment with letting the other voices catch up
  first?

  General idea is to introduce complexity gradually,
  or to find or arrive at a starting point for some
  other style of progression, like gradual widening
  of intervals or playing with varying accents.

  Another dimension for complexity:  total length of
  duration elements.  If they're not uniform, then
  re-arrangement will stagger voices.  To maintain
  uniform count, add rests?  What is consequence of
  unequal length of e.g. interval/rest, duration, 
  accent, dynamic?  Could pad accent and dynamic
  to avoid truncation.  Lengths of interval/rest
  and durations is trickier, either needs to cause
  truncation.
  
  Code:
  1) Capture configuration.  Lists of a) mottos,
     b) durations, c) accents, d) durations.  And
     per voice instrument, key, clef, scale, and
     starting pitch.
     Routine that merges to note list extends
     accents and durations, but truncates by 
     shortest of interval/rest or durations list.
     Or why not extend interval/rest with a series
     of zero transpositions?  Duration should be
     the determining factor so that, for a cycle
     all voices end a the same point.  Note that
     random selection will violate this.
  2) Create uniform unvarying texture with all
     voices starting from same pitch separated
     only by octaves  Repeat for some count.
  3) Advance interval/rest list by one with wrapping
     for top voice only.  Repeat.  And the same for
     each voice individually until they've all 
     landed at the same alignment.

  During the first step, repeat until the different
  mottos are sharply defined, different from each 
  other, and easy to recognize.

** TODO Motif Transitions
  - build longer-term transitions on top, e.g. migrate all 
    voices to a destination range: high, middle, low or
    transpose chromatically so different voices or pairs
    of voices are in different keys, or migrate starting
    mottos by cloning and repeating subsections or going
    the opposite direction so texture becomes either more
    sparse or more dense (e.g. by adding / removing rests),
    or units of repetition grow/shrink
  - pair-wise progressions so there's audible variety in
    the texture, e.g. outer voices chiming with inner 
    voices quietly busy
  - increasing sparsity of notes vs. rests to reduce
    texture to pointillistic dots
** TODO Barring
** TODO Non-pitched Percussion Voices


